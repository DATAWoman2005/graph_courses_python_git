---
title: "Global Insights Dashboard: Suicide, Happiness, and Internet Use"
author: "my_project"
format: dashboard
theme: superhero
---

```{python}
import pandas as pd
import plotly.express as px
import itables 
import country_converter as cc
from functools import reduce
```


```{python}
#| output: false
# happiness_score dataset
happiness_data = pd.read_csv("data\hapiscore_whr.csv")

happiness_data
```

```{python}
#| output: false
# changing dataset to a long format
happiness_data_long = happiness_data.melt(id_vars="country")
happiness_data_long
```

```{python}
#| output: false
# changing to representative column names
happiness_data_long = happiness_data.melt(id_vars="country", var_name="year", value_name = "percent_happiness").sort_values(["country", "year"])

happiness_data_long
```

```{python}
#| output: false
# checking datatype
happiness_data_long.dtypes
```

```{python}
#| output: false
# converting the 'year' column to integer type, and coercing errors to NaN
happiness_data_long['year'] = pd.to_numeric(happiness_data_long['year'], errors='coerce')

# Confirm the conversion
print(happiness_data_long['year'].dtype)

```

```{python}
#| output: false
# filtering for year 2015 to 2022
happiness_data_long = happiness_data_long[
    (happiness_data_long['year'] >= 2015) & (happiness_data_long['year'] <= 2022)
]

# Check the result
print(happiness_data_long['year'].unique())
print(happiness_data_long["country"].unique())
print(happiness_data_long.shape)
```

```{python}
#| output: false
# Updating rows where 'country' equals 'UAE'
happiness_data_long.loc[happiness_data_long['country'] == 'UAE', 'country'] = 'United Arab Emirates'

# Verify the change
print(happiness_data_long['country'].unique())
```

```{python}
#| output: false

# converting country names to ISO3 codes
happiness_data_long["country_code"] = cc.convert(happiness_data_long["country"], to="ISO3")

# Verify the result
print(happiness_data_long.head())
print(f"Shape after dropping invalid countries: {happiness_data_long.shape}")
```

```{python}
#| output: false

# unique number of countries in happiness dataset
happy_countries = happiness_data_long["country"].nunique()

happy_countries
```


```{python}
#| output: false
# suicide_rate dataset
suicide_rate = pd.read_csv("data\suicide_rate_data.csv")

suicide_rate
```

```{python}
#| output: false
# selecting applicable columns
suicide_rate_subset = suicide_rate [["Reference area", "Sex", "TIME_PERIOD", "OBS_VALUE"]]

suicide_rate_subset
```

```{python}
#| output: false
# changing to representative column names
suicide_rate_subset = suicide_rate_subset.rename(columns={"Reference area": "country", "Sex": "sex", "TIME_PERIOD": "year", "OBS_VALUE": "mortality_count"})

suicide_rate_subset = suicide_rate_subset.sort_values(["country", "year"])

suicide_rate_subset
```

```{python}
#| output: false
# dropping rows with 'OECD' or 'European Union' in the 'country' column 
# as only interested in single country names
suicide_rate_subset = suicide_rate_subset[
    ~suicide_rate_subset['country'].str.contains("OECD|European Union", case=False, na=False,regex=True)
]

# Verify the result
print(suicide_rate_subset['country'].unique())
print(f"Shape after dropping OECD and European Union rows: {suicide_rate_subset.shape}")

```

```{python}
#| output: false

# unique number of countries in happiness dataset
suic_country_count = suicide_rate_subset["country"].nunique()

suic_country_count
```

```{python}
#| output: false
# internet_use dataset
internet_use = pd.read_csv ("data\household_internet_use.csv")

internet_use 
```

```{python}
#| output: false
# selecting applicable columns
internet_use_subset = internet_use[["Reference area", "TIME_PERIOD", "OBS_VALUE"]]

internet_use_subset
```

```{python}
#| output: false
# changing to representative column names
internet_use_subset = internet_use_subset.rename(columns={"Reference area": "country", "TIME_PERIOD": "year", "OBS_VALUE": "percent_internet_household"})

internet_use_subset
```

```{python}
#| output: false
# dropping rows with 'OECD' or 'European Union' in the 'country' column
internet_use_subset = internet_use_subset[
    ~internet_use_subset['country'].str.contains("OECD|European Union", case=False, na=False,regex=True)
]

# Verify the result
print(internet_use_subset['country'].unique())
print(f"Shape after dropping OECD and European Union rows: {internet_use_subset.shape}")

```

```{python}
#| output: false
# rounding to 1 decimal for consistency with other datasets
internet_use_subset["percent_internet_household"] = internet_use_subset["percent_internet_household"].round(1)

internet_use_subset
```

```{python}
#| output: false
internet_use_subset["country_code"]  = cc.convert(internet_use_subset["country"], to="ISO3")


# Verify the result
print(internet_use_subset.head())
print(f"New shape of the DataFrame: {internet_use_subset.shape}")
```

```{python}
#| output: false
internet_use_subset = internet_use_subset.sort_values(["country","year"])
```


```{python}
#| output: false
#calculating missing values for each dataset
happiness_missing = happiness_data_long.isna().sum()
internet_missing = internet_use_subset.isna().sum()
suicide_missing = suicide_rate_subset.isna().sum()


# combining the results into a single DataFrame
missing_summary = pd.DataFrame({
   'dataset': ['percent_happiness', 'internet_use', 'suicide_rate'],
   'country': [happiness_missing['country'], internet_missing['country'], suicide_missing['country']],
   'year': [happiness_missing['year'], internet_missing['year'], suicide_missing['year']],
   'value_column': [happiness_missing['percent_happiness'], internet_missing['percent_internet_household'], suicide_missing['mortality_count']]
})

missing_summary                      
```

```{python}
#| output: false
# reshaping with melt and naming columns for clarity
missing_summary = missing_summary.melt(
    id_vars='dataset', var_name='dataset_columns', value_name='missing_count'
).sort_values('dataset')
missing_summary
```

```{python}
#| output: false
# bar chart for missing values
fig = px.bar(
    missing_summary,
    x='dataset_columns',
    y='missing_count',
    color='dataset',
    title='Missing Values per Column Across Datasets',
    labels={'missing_count': 'Count of Missing Values', 'dataset_columns': 'Columns'},
    barmode='group'
)

fig.show()
```

```{python}
#| output: false
# dropping missing value from dataset
happiness_data_long.dropna(inplace=True)

```

```{python}
#| output: false
# function to check any persistent missing values
def check_missing_data(df, name):
    print(f"Missing Data Summary for {name}:")
    print(df.isna().sum())
    print("-" * 40)

# Check for missing values in each dataset
check_missing_data(happiness_data_long, "Happiness Data")
check_missing_data(internet_use_subset, "Internet Use Data")
check_missing_data(suicide_rate_subset, "Suicide Rate Data")

```



```{python}
#| output: false
# creating a pivoted version of the 'suicide_rate_subset' dataFrame 
# to analyze mortality rates by sex (Male, Female, Total)
# without modifying the original 'suicide_rate_subset
# pivoting the data so each sex becomes its own column
suicide_rate_pivot = suicide_rate_subset.pivot_table(
    index=['country', 'year'],
    columns='sex',
    values='mortality_count',
    aggfunc='sum'  # Aggregate if duplicates exist
).reset_index()

# renaming the columns for clarity
suicide_rate_pivot.columns.name = None  # removing column index name
suicide_rate_pivot = suicide_rate_pivot.rename(columns={
    'Male': 'mortality_male',
    'Female': 'mortality_female',
    'Total': 'mortality_total'
})

# cleaned dataset
suicide_rate_pivot.head()
```

```{python}
#| output: false
# filtering to keep only the  rows with 'Total' values
suicide_rate_filtered = suicide_rate_subset[suicide_rate_subset["sex"] == "Total"]

suicide_rate_filtered
```

```{python}
#| output: false
# dropping the 'sex' column as it's no longer needed
suicide_rate_filtered = suicide_rate_filtered.drop(columns=["sex"]).sort_values(["country", "year"])

suicide_rate_filtered.head()
```

```{python}
#| output: false
suicide_rate_filtered ["country_code"] = cc.convert(suicide_rate_filtered ["country"], to="ISO3")

# Verify the result
print(suicide_rate_filtered .head())
print(f"New shape of the DataFrame: {suicide_rate_filtered.shape}")
```

```{python}
#| output: false
print(happiness_data_long.shape)
print(internet_use_subset.shape)
print(suicide_rate_filtered.shape)
print(suicide_rate_pivot.shape)

```


```{python}
#| output: false
# joining suicide_rate with happiness on 'country_code' and 'year'
data_frames = [suicide_rate_filtered, 
    happiness_data_long, internet_use_subset]
df_merged = reduce(lambda left, right: pd.merge(left, right,  on=['country_code','year'],
    how='outer'), data_frames)

# replacing missing values
# replacing NaN with 'Unknown' for object (string) columns
for col in df_merged.select_dtypes(include='object').columns:
    df_merged[col].fillna('Unknown', inplace=True)

# replacing NaN with -1 for numeric columns
for col in df_merged.select_dtypes(include='number').columns:
    df_merged[col].fillna(-1, inplace=True)

df_merged.head(20)
```

```{python}
#| output: false
df_merged = df_merged.drop(columns=["country_x", "country"])
df_merged.rename(columns={"country_y": "country"}, inplace=True)
df_merged.head(20)
```

```{python}
#| output: false
# rearranging columns in a more intuitive order
column_order = ['country_code', 'country', 'year', 'percent_happiness', 'mortality_count', 'percent_internet_household']
if set(column_order).issubset(df_merged.columns):
    df_merged = df_merged[column_order]

# Check the data types
df_merged
```

```{python}
#| output: false
df_merged.to_csv('final_merged.csv', index=False)
```

```{python}
#| output: false

# Key metrics
avg_happiness = df_merged['percent_happiness'].mean()
lowest_happy_perc = df_merged['percent_happiness'].min()
highest_happy_perc = df_merged['percent_happiness'].max()

highest_happiness_country = df_merged.loc[df_merged["percent_happiness"].idxmax(), 'country']
highest_happy_perc = df_merged['percent_happiness'].max()
lowest_happiness_country = df_merged.loc[df_merged["percent_happiness"].idxmin(), 'country']

# Combine the name and score for display
formatted_value = f"{highest_happiness_country} ({highest_happy_perc:.1f})"

# Display the value in the dashboard
formatted_value 
```

```{python}
#| output: false

# filtering data for the year 2022
df_2022 = df_merged[df_merged['year'] == 2022]

# calculating Canada's percentage and rank in 2022
canada_percentage = df_2022.loc[df_2022['country'] == 'Canada', 'percent_happiness'].values[0]
canada_rank = int(df_2022['percent_happiness'].rank(ascending=False).loc[df_2022['country'] == 'Canada'].values[0])

# Determine ordinal suffix for the rank
def get_ordinal_suffix(rank):
    if 10 <= rank % 100 <= 20:
        suffix = 'th'
    else:
        suffix = {1: 'st', 2: 'nd', 3: 'rd'}.get(rank % 10, 'th')
    return f"{rank}{suffix}"

canada_rank_with_suffix = get_ordinal_suffix(canada_rank)

# Print results
print(f"Canada's percentage in 2022: {canada_percentage}%")
print(f"Canada's rank in 2022: {canada_rank_with_suffix} out of {len(df_2022)} countries")

# Create a bar chart to visualize the comparison
fig = px.bar(
    df_2022.sort_values('percent_happiness', ascending=False),
    x='country',
    y='percent_happiness',
    title=f"Happiness Percentages by Country in 2022 (Canada: {canada_rank_with_suffix})",
    labels={'percent_happiness': 'Happiness Percentage'},
    text='percent_happiness'
)

# Highlight Canada in the chart
fig.update_traces(
    marker=dict(color=['#636EFA' if country == 'Canada' else '#EF553B' for country in df_2022['country']]),
    textposition='outside'
)

# Enlarge chart title
fig.update_layout(
    title=dict(
        text=f"Happiness Percentages by Country in 2022 (Canada: {canada_rank_with_suffix})",
        font=dict(size=24)  # Adjust the font size here
    )
)


fig.show()


```

```{python}
#| output: false


# Filter the DataFrame for the year 2022
filtered_df = df_merged.query("year == 2022")

# Verify that country_code uses ISO Alpha-3 and percent_happiness is numeric
print(filtered_df[['country_code', 'percent_happiness']].dtypes)

# Create the choropleth map
map_fig = px.choropleth(
    filtered_df,
    locations="country_code",              # ISO Alpha-3 country codes
    locationmode="ISO-3",                  # Explicitly set the location mode
    color="percent_happiness",             # Numeric column to represent with color
    hover_name="country",                  # Hover information
    title="Happiness Score by Country",
    color_continuous_scale="YlGnBu",       # Correct color scale
)

# Update map layout for better appearance
map_fig.update_layout(
    geo=dict(
        showframe=False,
        showcoastlines=True,
        projection_type='equirectangular'  # Map projection type
    )
)

# Display the map
map_fig.show()

```


```{python}

# Filter out rows where mortality_count is -1
filtered_df = df_merged[df_merged['mortality_count'] != -1]

avg_mortality = filtered_df['mortality_count'].mean()
highest_mortality = filtered_df.loc[filtered_df['mortality_count'].idxmax(), ['country', 'mortality_count']]
lowest_mortality = filtered_df.loc[filtered_df['mortality_count'].idxmin(), ['country', 'mortality_count']]

print(f"Average Mortality Rate: {avg_mortality:.1f}")
print(f"Highest Mortality Rate: {highest_mortality['country']} ({highest_mortality['mortality_count']})")
print(f"Lowest Mortality Rate: {lowest_mortality['country']} ({lowest_mortality['mortality_count']})")

```


# Happiness Board

## {height = "20%"}

::: {.valuebox title="Number of Countries" color="primary"}
**`{python} happy_countries`**
:::

::: {.valuebox title="Average Percent Score of Happiness" color="primary"}
**`{python} str(avg_happiness.round(1))`**
:::

::: {.valuebox title="Country with the happiest people" color="primary"}
**`{python} formatted_value`**
:::

## Row{80%}

```{python}
map_fig
```

### Column

```{python}
fig.show()
```


# Page 2
## Row

## {height = "20%"}

::: {.valuebox title="Number of Countries" color="primary"}
**`{python} suic_country_count`**
:::

::: {.valuebox title="Average Mortality Count Per Hundred Thousand People" color="primary"}
**`{python} str(avg_mortality.round(1))`**
:::

::: {.valuebox title="Country with the happiest people" color="primary"}

:::

## Row{80%}

```{python}

```

### Column

```{python}

```
